## try http:// if https:// URLs are not supported
source("https://bioconductor.org/biocLite.R")
biocLite()
install.packages("dplyr")
install.packages("ggplot2")
install.packages("tidyr")
install.packages("stringr")
install.packages("knitr")
install.packages("rmarkdown")
install.packages("stringr")
install.packages("ggtree")
biocLite("ggree")
biocLite("ggtree")
source("http://bioconductor.org/biocLite.R")
biocLite()
biocLite("ggtree")
lubrary(ggtree)
library(ggtree)
library(ggtree)
install.packages("Rcpp")
install.packages(file.choose(), type = "source", repos = NULL)
library("rEDM")
library(rEDM)
library(rEDM)
data(tentmap_del)
head(tentmap_del)
library("rEDM")
data(tentmap_del)
library(devtools)
install_github("ha0ye/rEDM")
vignette("rEDM-tutorial")
library(rEDM)
data(tentmap_del)
head(tentmap_del)
str(tentmap_del)
ts <- tentmap_del
lib <- c(1, 100)
pred <- c(201, 500)
simplex_output <- simplex(ts, lib, pred)
str(simplex_output)
par(mar = c(4, 4, 1, 1), mgp = c(2.5, 1, 0))  # set up margins for plotting
plot(simplex_output$E, simplex_output$rho, type = "l", xlab = "Embedding Dimension (E)",
ylab = "Forecast Skill (rho)")
data(block_3sp)
str(block_3sp)
cols <- c(1, 2, 4)  # c('x_t', 'x_t-1', 'y_t')
target <- 1  # 'x_t'
block_lnlp_output <- block_lnlp(block_3sp, lib = lib, pred = pred, columns = cols,
target_column = target, stats_only = FALSE, first_column_time = TRUE)
str(block_lnlp_output)
block_lnlp_output <- block_lnlp(block_3sp, lib = lib, pred = pred, columns = cols,
target_column = target, stats_only = FALSE, first_column_time = TRUE)
x <- readClipboard()
x <- read.table(file = "clipboard", sep = "t", header=TRUE)
x
x <- read.table(file = "clipboard", sep = "t", header=TRUE)
x <- read.table(pipe("pbpaste"), sep="\t", header=TRUE) # for a data frame
x
str(x)
plot(x[,2]~x[,1])
plot(x[,3]~x[,1])
library(knitr)#; library(zoo); library(xts)
library(rEDM)
library(ggplot2)#; library(cowplot)
library(dplyr); library(tidyr)
library(deSolve)
library(xts)
library(rgl)
library(scatterplot3d)
opts_chunk$set(fig.align = 'center',
fig.show = 'hold',
fig.height = 5,
warning = FALSE, message = FALSE, error = FALSE, echo=FALSE)
options(formatR.arrow = TRUE,width = 90)###, cache=TRUE)
install.packages("rEDM")
library(knitr)#; library(zoo); library(xts)
library(rEDM)
library(rEDM)
library(ggplot2)#; library(cowplot)
library(dplyr); library(tidyr)
library(ggplot2)#; library(cowplot)
library(dplyr); library(tidyr)
library(deSolve)
library(rgl)
library(scatterplot3d)
opts_chunk$set(fig.align = 'center',
fig.show = 'hold',
fig.height = 5,
warning = FALSE, message = FALSE, error = FALSE, echo=FALSE)
options(formatR.arrow = TRUE,width = 90)##
vignette("rEDM-tutorial", package="rEDM")
time1<-seq(1, 100, by = 0.2)
x1<-sin(time1)
y1<-cos(time1)
plot(x1, y1, type = 'p', main = "State-space of harmonic oscilator",
cex=0.2, xlab="X", ylab="Y")
plot(time1, x1, type = 'l', main = "Time series of the variables of the system", col = "red")
lines(time1, y1, col = "blue")
plot(time1, x1, type = 'l', main = "Time series of the variables of the system", col = "red")
lines(time1, y1, col = "blue")
plot(time1, x1, type = 'l', main = "Time series of the variables of the system", col = "red")
lines(time1, y1, col = "blue")
vignette("rEDM-tutorial", package="rEDM")
library(knitr)#; library(zoo); library(xts)
library(plotly)
library(rEDM)
library(ggplot2)#; library(cowplot)
library(dplyr); library(tidyr)
## Two vectors to store data
X <- c()
Y <- c()
## Initial values
X[1] <- 0.1
Y[1] <- 0.3
X[2] <- 0.3
Y[2] <- 3.78*Y[1] - 3.78*Y[1]^2
## Iterate the dynamics 150 time steps
for(i in 3:150){
X[i] <- 3.77*X[i-1] - 3.77*X[i-1]^2 - 0.85*Y[i-1]*X[i-1] - 0.5*X[i-2]
Y[i] <- 3.78*Y[i-1] - 3.78*Y[i-1]^2
}
X
Y
predE3 <- simplex(time_series = X, E = 3, stats_only = FALSE)
library(rEDM)
predE3 <- simplex(time_series = X, E = 3, stats_only = FALSE)
## Two vectors to store data
X <- c()
Y <- c()
## Initial values
X[1] <- 0.1
Y[1] <- 0.3
X[2] <- 0.3
Y[2] <- 3.78*Y[1] - 3.78*Y[1]^2
## Iterate the dynamics 150 time steps
for(i in 3:150){
X[i] <- 3.77*X[i-1] - 3.77*X[i-1]^2 - 0.85*Y[i-1]*X[i-1] - 0.5*X[i-2]
Y[i] <- 3.78*Y[i-1] - 3.78*Y[i-1]^2
}
predE3 <- simplex(time_series = X, E = 3, stats_only = FALSE)
predE3 <- simplex(time_series = X, E = 3, stats_only = FALSE)
fits <- predE3$model_output[[1]]
plot(pred ~ time, data = fits, type = "l", col = "blue", lwd=3,
xlab="Time", ylab="X", ylim=range(fits[,2:3]))
lines(obs ~ time, data = fits, col=grey.colors(1, alpha=0.25), lwd = 6)
legend("topright", c("Observed", "Predicted"), lty=1, lwd=c(6,3),
col=c(grey.colors(1, alpha=0.25), "blue"),bty="n")
plot(pred ~ time, data = fits, type = "l", col = "blue", lwd=3,
xlab="Time", ylab="X", ylim=range(fits[,2:3]))
lines(obs ~ time, data = fits, col=grey.colors(1, alpha=0.25), lwd = 6)
legend("topright", c("Observed", "Predicted"), lty=1, lwd=c(6,3),
col=c(grey.colors(1, alpha=0.25), "blue"),bty="n")
predE2 <- simplex(time_series = X, E = c(2,3,10), stats_only = FALSE)
par(mfrow=c(1,3))
plot(pred ~ obs, data = predE2$model_output[[1]],
main = bquote("Embedding = 2, " ~ rho == .(round(predE2$rho[1],2))))
plot(pred ~ obs, data = predE2$model_output[[2]],
main = bquote("Embedding = 3, " ~ rho == .(round(predE2$rho[2],2))))
plot(pred ~ obs, data = predE2$model_output[[3]],
main = bquote("Embedding = 10, " ~ rho == .(round(predE2$rho[3],2))))
par(mfrow=c(1,1))
find.emb <- simplex(time_series = X, E = 1:10)
plot(rho ~ E, data=find.emb, type="b",
xlab = "Embedding dimensions",
ylab = expression(paste("Forecast skill (",rho,")",sep="")))
find.emb <- simplex(time_series = X, E = 1:10)
plot(rho ~ E, data=find.emb, type="b",
xlab = "Embedding dimensions",
ylab = expression(paste("Forecast skill (",rho,")",sep="")))
find.emb <- simplex(time_series = X, E = 1:10)
plot(rho ~ E, data=find.emb, type="b",
xlab = "Embedding dimensions",
ylab = expression(paste("Forecast skill (",rho,")",sep="")))
predE3tp5 <- simplex(time_series = X, E = 3, tp = 5, stats_only = FALSE)
fitstp5 <- predE3tp5$model_output[[1]]
plot(pred ~ obs, data = fitstp5)
points(pred ~ obs, data = fitstp5[nrow(fitstp5),], col = "blue", pch=19)
plot(pred ~ time, data = fitstp5, type = "l", col = "blue", lwd=3,
xlab="Time", ylab="X", ylim=range(fitstp5[,2:3]))
lines(obs ~ time, data = fitstp5, col=grey.colors(1, alpha=0.25), lwd = 6)
legend("topright", c("Observed", "Predicted"), lty=1, lwd=c(6,3),
col=c(grey.colors(1, alpha=0.25), "blue"),bty="n", cex=1.5)
dev.off()
predE3tp5 <- simplex(time_series = X, E = 3, tp = 5, stats_only = FALSE)
fitstp5 <- predE3tp5$model_output[[1]]
plot(pred ~ obs, data = fitstp5)
points(pred ~ obs, data = fitstp5[nrow(fitstp5),], col = "blue", pch=19)
plot(pred ~ time, data = fitstp5, type = "l", col = "blue", lwd=3,
xlab="Time", ylab="X", ylim=range(fitstp5[,2:3]))
lines(obs ~ time, data = fitstp5, col=grey.colors(1, alpha=0.25), lwd = 6)
legend("topright", c("Observed", "Predicted"), lty=1, lwd=c(6,3),
col=c(grey.colors(1, alpha=0.25), "blue"),bty="n", cex=1.5)
pred.decay <- simplex(time_series = X, E = 3, tp = 1:10)
plot(rho ~ tp, data=pred.decay,
type = "b",
xlab = "Time to prediction",
ylab = expression(paste("Forecast skill (",rho,")",sep="")))
X2 <- c()
X2[1] <- 0.5
for(i in 2:150)
X2[i] <- 3.569949 * X2[i-1] * ( 1- X2[i-1] )
## Plots the series
plot(X2, xlab="Time", ylab="X", type="b", lty=3)
find.emb2 <- simplex(time_series = X2, E = 1:10)
plot(rho ~ E, data=find.emb2, type="b",
ylim=c(0,1),
xlab = "Embedding dimensions",
ylab = expression(paste("Forecast skill (",rho,")",sep="")))
find.emb2 <- simplex(time_series = X2, E = 1:10)
plot(rho ~ E, data=find.emb2, type="b",
ylim=c(0,1),
xlab = "Embedding dimensions",
ylab = expression(paste("Forecast skill (",rho,")",sep="")))
pred.decay2 <- simplex(time_series = X2, E = 6, tp = 1:50)
plot(rho ~ tp, data=pred.decay2,
type = "l",
xlab = "Time to prediction",
ylab = expression(paste("Forecast skill (",rho,")",sep="")),
ylim = c(0,1))
## Adding noise
X3 <- X2 + rnorm(n = length(X2), mean = 0, sd = sd(X2))
## Plot series
plot(X3, xlab="Time", ylab="X", type="b", lty=3)
## Adding noise
X3 <- X2 + rnorm(n = length(X2), mean = 0, sd = sd(X2))
## Plot series
plot(X3, xlab="Time", ylab="X", type="b", lty=3)
pred.decay3 <- simplex(time_series = X3, E = 6, tp = 1:50)
plot(rho ~ tp, data=pred.decay3,
type = "l",
xlab = "Time to prediction",
ylab = expression(paste("Forecast skill (",rho,")",sep="")),
ylim = c(0,1))
library(knitr)#; library(zoo); library(xts)
library(plotly)
library(rEDM)
library(ggplot2)#; library(cowplot)
library(dplyr); library(tidyr)
opts_chunk$set(fig.align = 'center',
fig.show = 'hold',
fig.height = 5,
warning = FALSE, message = FALSE, error = FALSE, echo=FALSE)
options(formatR.arrow = TRUE,width = 90)###, cache=TRUE)
## Two vectors to store data
X <- c()
Y <- c()
## Initial values
X[1] <- 0.1
Y[1] <- 0.3
X[2] <- 0.3
Y[2] <- 3.78*Y[1] - 3.78*Y[1]^2
## Iterate the dynamics 150 time steps
for(i in 3:150){
X[i] <- 3.77*X[i-1] - 3.77*X[i-1]^2 - 0.85*Y[i-1]*X[i-1] - 0.5*X[i-2]
Y[i] <- 3.78*Y[i-1] - 3.78*Y[i-1]^2
}
plot(X, xlab="Time", ylab="X", type="b", lty=3)
## Data frame with X at t0, t1 and t2
df1 <- data.frame(X.t0=X[1:(length(X)-2)],X.t1=X[2:(length(X)-1)],  X.t2=X[3:(length(X))])
## point to point Euclidian distance matrix
dist.m1 <- as.matrix(dist(df1[,1:3], upper=TRUE))
## Indexes of the 4 nearest neighbors of the last point in the time series
neigb1 <- order(dist.m1[(ncol(dist.m1)-1),])[2:5]
## Plot of the manifold: add colored markers on last point and their neighbors
p3 <- plot_ly(df1, x = ~X.t0, y=~X.t1, z=~X.t2, marker=(list(color=grey)), opacity=0.25) %>%
layout(scene = list(xaxis = list(title = 'X'),
yaxis = list(title = 'X (t+1)'),
zaxis = list(title = 'X (t+2)'))) %>%
add_markers(text = paste("time =",3:length(X)), showlegend = FALSE) %>%
add_trace( x = ~X.t0, y=~X.t1, z=~X.t2, data=df1[c(length(X)-3,neigb1),],
opacity=1,
marker=list(color=c("blue","red","green","orange", "magenta")),
type="scatter3d", mode="markers",
text = paste("time =",rownames(df1[c(length(X)-3,neigb1),])), showlegend = FALSE) %>%
add_trace(data=df1[c(length(X)-3, neigb1[1]),], mode="lines",
line = list(width = 6, color = "blue"), showlegend = FALSE) %>%
add_trace(data=df1[c(length(X)-3, neigb1[2]),], mode="lines",
line = list(width = 6, color = "blue"), showlegend = FALSE)%>%
add_trace(data=df1[c(length(X)-3, neigb1[3]),], mode="lines",
line = list(width = 6, color = "blue"), showlegend = FALSE) %>%
add_trace(data=df1[c(length(X)-3, neigb1[4]),], mode="lines",
line = list(width = 6, color = "blue"), showlegend = FALSE)
p3
time1 <- min(neigb1,length(X)):length(X) # syntatic sugar
plot(time1, X[time1] , xlab="Time", ylab="X", type="b", lty=3)
cores <- c("blue", "red","green","orange", "magenta")
z <- 1
for(i in c(length(X)-3,neigb1)){
ind <- i:(i+2)
lines(ind, X[ind], type="b", col=cores[z], lwd=2, pch=19)
z <- z+1}
plot(time1, X[time1] , xlab="Time", ylab="X", type="b", lty=3)
cores <- c("blue", "red","green","orange", "magenta")
z <- 1
for(i in c(length(X)-2,neigb1+1)){
ind <- i:(i+2)
lines(ind, X[ind], type="b", col=cores[z], lwd=2, pch=19)
z <- z+1}
arrows(x0=neigb1+3, y0=X[neigb1+3], x1=length(X)*.99, y1=X[neigb1+3],
col=cores[-1])
points(length(X), X[length(X)], pch=17, cex=1.5)
s1 <- simplex(X, E=3, stats_only=FALSE)$model_output[[1]]
p1.last <- s1$pred[nrow(s1)]
pred.df <- df1[c(length(X)-2,neigb1+1),]
pred.df[1,3] <- p1.last
p4 <-
p3 %>%
add_trace( x = ~X.t0, y=~X.t1, z=~X.t2, data=pred.df,
marker=list(color=c("black","red","green","orange", "magenta")),
type="scatter3d", mode="marker",opacity=1,
text = paste("time = ",rownames(pred.df)), showlegend = FALSE) %>%
add_trace(data=pred.df[c(1,2),], mode="lines",
line = list(width = 6, color = "blue"), showlegend = FALSE) %>%
add_trace(data=pred.df[c(1,3),], mode="lines",
line = list(width = 6, color = "blue"), showlegend = FALSE) %>%
add_trace(data=pred.df[c(1,4),], mode="lines",
line = list(width = 6, color = "blue"), showlegend = FALSE) %>%
add_trace(data=pred.df[c(1,5),], mode="lines",
line = list(width = 6, color = "blue"), showlegend = FALSE) %>%
add_trace( x = ~X.t0, y=~X.t1, z=~X.t2, data=df1[nrow(df1),],
opacity=1,
marker=list(color=c("blue")),
type="scatter3d", mode="markers")
#p4
htmlwidgets::saveWidget(as_widget(p4), file = "p4.html")
include_url("p4.html", height="600px")
nich97I <- read.csv("https://www.stat.berkeley.edu/~brill/blowfly97I")
plot(nich97I$total, type="b", xlab="Time", ylab="Total number of flies")
install.packages(c("ade4", "adehabitatHR", "adehabitatLT", "adehabitatMA", "adephylo", "backports", "BoSSA", "caret", "chron", "circlize", "cowplot", "crul", "ctv", "curl", "dfoptim", "digest", "dotCall64", "DRR", "earth", "ecospat", "foreach", "fpc", "GenSA", "git2r", "haven", "hexbin", "Hmisc", "HMP", "hms", "htmlTable", "htmlwidgets", "irlba", "iterators", "KFAS", "knitr", "ks", "lava", "lme4", "MASS", "mclust", "mgcv", "msm", "pbapply", "phyclust", "phylotools", "plotrix", "pomp", "pracma", "quantmod", "rasterVis", "Rcpp", "RcppArmadillo", "RCurl", "recipes", "registry", "reshape2", "rgdal", "rgl", "rlang", "Rmpfr", "rms", "rpart", "rprojroot", "rsq", "segmented", "sf", "sp", "spam", "spatstat", "spatstat.utils", "spdep", "stargazer", "tibble", "tm", "tmap", "tmaptools", "units", "urltools", "vegan", "viridis", "webshot", "wikitaxa", "withr", "xts", "yaml", "zoo"))
install.packages(c("ade4", "adehabitatHR", "adehabitatLT", "adehabitatMA", "adephylo", "backports", "BoSSA", "caret", "chron", "circlize", "cowplot", "crul", "ctv", "curl", "dfoptim", "digest", "dotCall64", "DRR", "earth", "ecospat", "foreach", "fpc", "GenSA", "git2r", "haven", "hexbin", "Hmisc", "HMP", "hms", "htmlTable", "htmlwidgets", "irlba", "iterators", "KFAS", "knitr", "ks", "lava", "lme4", "MASS", "mclust", "mgcv", "msm", "pbapply", "phyclust", "phylotools", "plotrix", "pomp", "pracma", "quantmod", "rasterVis", "Rcpp", "RcppArmadillo", "RCurl", "recipes", "registry", "reshape2", "rgdal", "rgl", "rlang", "Rmpfr", "rms", "rpart", "rprojroot", "rsq", "segmented", "sf", "sp", "spam", "spatstat", "spatstat.utils", "spdep", "stargazer", "tibble", "tm", "tmap", "tmaptools", "units", "urltools", "vegan", "viridis", "webshot", "wikitaxa", "withr", "xts", "yaml", "zoo"))
install.packages(c("ade4", "adehabitatHR", "adehabitatLT", "adehabitatMA", "adephylo", "backports", "BoSSA", "caret", "chron", "circlize", "cowplot", "crul", "ctv", "curl", "dfoptim", "digest", "dotCall64", "DRR", "earth", "ecospat", "foreach", "fpc", "GenSA", "git2r", "haven", "hexbin", "Hmisc", "HMP", "hms", "htmlTable", "htmlwidgets", "irlba", "iterators", "KFAS", "knitr", "ks", "lava", "lme4", "MASS", "mclust", "mgcv", "msm", "pbapply", "phyclust", "phylotools", "plotrix", "pomp", "pracma", "quantmod", "rasterVis", "Rcpp", "RcppArmadillo", "RCurl", "recipes", "registry", "reshape2", "rgdal", "rgl", "rlang", "Rmpfr", "rms", "rpart", "rprojroot", "rsq", "segmented", "sf", "sp", "spam", "spatstat", "spatstat.utils", "spdep", "stargazer", "tibble", "tm", "tmap", "tmaptools", "units", "urltools", "vegan", "viridis", "webshot", "wikitaxa", "withr", "xts", "yaml", "zoo"))
install.packages(c("ade4", "adehabitatHR", "adehabitatLT", "adehabitatMA", "adephylo", "backports", "BoSSA", "caret", "chron", "circlize", "cowplot", "crul", "ctv", "curl", "dfoptim", "digest", "dotCall64", "DRR", "earth", "ecospat", "foreach", "fpc", "GenSA", "git2r", "haven", "hexbin", "Hmisc", "HMP", "hms", "htmlTable", "htmlwidgets", "irlba", "iterators", "KFAS", "knitr", "ks", "lava", "lme4", "MASS", "mclust", "mgcv", "msm", "pbapply", "phyclust", "phylotools", "plotrix", "pomp", "pracma", "quantmod", "rasterVis", "Rcpp", "RcppArmadillo", "RCurl", "recipes", "registry", "reshape2", "rgdal", "rgl", "rlang", "Rmpfr", "rms", "rpart", "rprojroot", "rsq", "segmented", "sf", "sp", "spam", "spatstat", "spatstat.utils", "spdep", "stargazer", "tibble", "tm", "tmap", "tmaptools", "units", "urltools", "vegan", "viridis", "webshot", "wikitaxa", "withr", "xts", "yaml", "zoo"))
library("rEDM")
help("make_block")
?lmerTest
help(lmerTest)
cite("lme4")
citation("lme4")
version("lme4")
packageVersion("lme4")
(exp(-8)*(8^10))/factorial(10)
8^10
8^10/factorial(10)
0.0003*296
exp(-8)
# Created by Marina Costa Rillo in 05/July/2018
rm(list=ls())
# Libraries
library(reshape)
library(geosphere)
library(SpadeR)
library(ggplot2)
library(viridis)
library(dplyr)
library(ggpubr)
library(lme4)
library(xtable)     # prints table in Latex format
# Auxiliary functions
'%!in%' <- function(x,y)!('%in%'(x,y))
find_neighbours <- function(point, findin, distance) { # vector, data.frame, numeric
## point: vector of two numbers (longitude, latitude)
## findin: a matrix of 2 columns (first one is longitude, second is latitude)
## distance: if 0 finds nearest neighbour, if a positive value (in meters) finds neighbours within a circle with the value radius
## Returns a data.frame:
## "row" = the row number of the neighbour in data.frame
## "distance" = the distance between the points
dist_data <- apply(findin, 1, function(x) distCosine(point, x)) #Matrix
if(distance>0) { # find neighbours within radius of distance
neighb <- data.frame(row_findin = which(dist_data<=distance), distance = dist_data[which(dist_data<=distance)])
if(length(neighb[,1])==0) distance = 0
}
if(distance==0) { # find nearest neighbour
neighb <- data.frame(row_findin = which(dist_data == dist_data[which.min(dist_data)]), distance = min(dist_data))
}
return(neighb)
}
function_name_grid <- function(data){
### Description
# This function receives the ForCenS data, and returns the ForCenS data with three extra columns: 'factorLatitude', 'factorLongitude' & 'grid_name'
### Arguments
# data
# transform the latitudes and longitudes to positive numbers
data$factorLatitude <- (data$Lat + 90)
data$factorLongitude <- (data$Long + 180)
# print(data$factorLatitude)
# print(data$factorLongitude)
# creating names for each longitude interval (numbers 1 to 36)
long_min <- seq(0, 350 , by=10)
long_max <- seq(10, 360, by=10)
long_name <- seq(1:36)
long_data <- data.frame(long_min, long_max, long_name)
# creating names for each latitude interval (letters)
lat_min <- seq(0, 170, by=10)
lat_max <- seq(10, 180, by= 10)
lat_name <-  letters [1:18]
lat_data <- data.frame(lat_min, lat_max, lat_name)
# creating new column to add square/grid name
data[,"grid_name"] <- NA
for (i in 1:nrow(data)){ # i goes through the rows of the ForCenS data set
# i = 1
lat_smaller <- which(lat_data$lat_min < data[i,"factorLatitude"]) # latitudes smaller than latitude from data
lat_larger <- which(lat_data$lat_max >= data[i,"factorLatitude"]) # latitudes larger than latitude from data
lat_line <- intersect(lat_smaller,lat_larger) # row of the lat_data that you want: intersect between all smaller and all larger gives the one you want
# Double check:
# print(paste("ForCenS lat:", data[i,"factorLatitude"]))
# print(lat_data[lat_line,])
long_smaller <- which(long_data$long_min < data[i,"factorLongitude"]) # longitudes smaller than longitudes from data
long_larger <- which(long_data$long_max >= data[i,"factorLongitude"]) # longitudes larger than longitudes from data
long_line <- intersect(long_smaller,long_larger) # row of long_data that you want
# Double check:
# print(paste("ForCenS long:", data[i,"factorLongitude"]))
# print(long_data[long_line,])
data[i,"grid_name"] <- paste(lat_data[lat_line,"lat_name"], long_data[long_line,"long_name"], sep="")
}
# grid names as factors
data$grid_name <- as.factor(data$grid_name)
return(data)
}
###
### Data
###
setwd("/Users/marinacostarillo/Google Drive/PhD/Projects/buckley-bias/short_paper")
historical <- read.csv("historical_data.csv", header = TRUE)
holocene_full <- read.csv("ForCenS_woa.csv", header = TRUE)
lgm_full <- read.csv("LGM_MARGO_renamed.csv", header = TRUE)
# Finding ForCenS neigbours of LGM
if (!file.exists("LGM_ForCenS_neighbours.csv")){
forcens_lgm <- data.frame()
for(j in 1:nrow(lgm_full)){
point <- as.numeric(lgm_full[j,c("Long","Lat")])
forcens_neighb <- find_neighbours(point, findin = holocene_full[,c("Longitude","Latitude")], distance = 0)
forcens_lgm <- rbind(forcens_lgm, cbind(lgm_row = j, lgm_long = point[1], lgm_lat = point[2],
forcens_neighb, holocene_full[forcens_neighb$row_findin,]))
}
write.csv(forcens_lgm, "LGM_ForCenS_neighbours.csv", row.names = F)
}else{
forcens_lgm <- read.csv("LGM_ForCenS_neighbours.csv", header = TRUE)
}
dim(forcens_lgm)
dim(unique(forcens_lgm[,c("lgm_lat", "lgm_long", "distance")]))
unique_lgm <- unique(forcens_lgm[,c("lgm_lat", "lgm_long", "distance")])
median(unique_lgm$distance/1000) # km
mean(unique_lgm$distance/1000) # km
version
version(sparse.model.matrix())
library(SpadeR)
session()
session
Session()
print(sessionInfo())
